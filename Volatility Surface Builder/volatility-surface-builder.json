{
  "name": "Volatility Surface Construction Engine",
  "version": 1,
  "tags": ["volatility", "options", "pricing", "derivatives"],
  "description": "Builds and maintains real-time volatility surfaces for options pricing, risk management, and trading strategies",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            15
          ],
          "hour": [
            "6-20"
          ],
          "minute": [
            "0,15,30,45"
          ]
        }
      },
      "id": "volatility-update-trigger",
      "name": "Volatility Surface Update Trigger",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [
        240,
        300
      ]
    },
    {
      "parameters": {
        "sql": "SELECT \n    symbol,\n    expiration_date,\n    strike_price,\n    option_type,\n    bid_price,\n    ask_price,\n    last_price,\n    volume,\n    open_interest,\n    implied_volatility,\n    underlying_price,\n    update_timestamp\nFROM options_chain_data \nWHERE expiration_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '2 years'\nAND update_timestamp >= NOW() - INTERVAL '1 hour'\nAND symbol IN ('SPX', 'NDX', 'RUT')",
        "additionalFields": {}
      },
      "id": "fetch-options-chain",
      "name": "Fetch Options Chain Data",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        460,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "// Clean and validate options data\nconst cleanOptionsData = (optionsData) => {\n  return optionsData.filter(option => {\n    // Filter out invalid data points\n    return option.bid_price > 0 && \n           option.ask_price > 0 && \n           option.strike_price > 0 &&\n           option.underlying_price > 0 &&\n           option.expiration_date &&\n           option.implied_volatility > 0 &&\n           option.implied_volatility < 5; // Filter out unrealistic IVs\n  }).map(option => ({\n    ...option,\n    mid_price: (option.bid_price + option.ask_price) / 2,\n    spread: option.ask_price - option.bid_price,\n    days_to_expiry: Math.max(1, Math.floor((new Date(option.expiration_date) - new Date()) / (1000 * 60 * 60 * 24))),\n    moneyness: option.strike_price / option.underlying_price\n  }));\n};\n\nconst cleanedData = cleanOptionsData(items.map(item => item.json));\nreturn cleanedData.map(item => ({ json: item }));"
      },
      "id": "clean-options-data",
      "name": "Clean and Validate Options Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        680,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "// Build volatility surface using SVI parameterization\nconst buildVolatilitySurface = (optionsData) => {\n  const surfaces = {};\n  \n  // Group by symbol and expiration\n  const groupedData = {};\n  optionsData.forEach(option => {\n    const key = `${option.symbol}_${option.expiration_date}`;\n    if (!groupedData[key]) {\n      groupedData[key] = [];\n    }\n    groupedData[key].push(option);\n  });\n  \n  // Build surface for each symbol/expiration\n  Object.keys(groupedData).forEach(key => {\n    const [symbol, expiration] = key.split('_');\n    const expirationData = groupedData[key];\n    \n    // Fit SVI parameters\n    const sviParams = fitSVIParameters(expirationData);\n    \n    // Create volatility grid\n    const volatilityGrid = createVolatilityGrid(sviParams, expirationData[0].underlying_price);\n    \n    surfaces[key] = {\n      symbol: symbol,\n      expiration_date: expiration,\n      calculation_timestamp: new Date().toISOString(),\n      underlying_price: expirationData[0].underlying_price,\n      svi_parameters: sviParams,\n      volatility_grid: volatilityGrid,\n      data_points: expirationData.length,\n      fit_quality: calculateFitQuality(sviParams, expirationData)\n    };\n  });\n  \n  return Object.values(surfaces);\n};\n\n// SVI parameter fitting (simplified)\nconst fitSVIParameters = (optionsData) => {\n  // Simplified SVI fitting - in production would use optimization\n  const strikes = optionsData.map(o => o.strike_price);\n  const ivs = optionsData.map(o => o.implied_volatility);\n  \n  return {\n    a: 0.04,\n    b: 0.10,\n    rho: -0.30,\n    m: 1.0,\n    sigma: 0.10,\n    fit_timestamp: new Date().toISOString()\n  };\n};\n\n// Create volatility grid\nconst createVolatilityGrid = (sviParams, spotPrice) => {\n  const grid = [];\n  const moneynessRange = [0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5];\n  const tenorRange = [7, 30, 60, 90, 180, 365, 730]; // days\n  \n  tenorRange.forEach(tenor => {\n    moneynessRange.forEach(moneyness => {\n      const strike = spotPrice * moneyness;\n      const iv = calculateSVIVolatility(sviParams, moneyness, tenor / 365);\n      \n      grid.push({\n        moneyness: moneyness,\n        strike: strike,\n        tenor_days: tenor,\n        implied_volatility: iv,\n        delta: calculateDelta(iv, moneyness, tenor / 365)\n      });\n    });\n  });\n  \n  return grid;\n};\n\n// Calculate SVI volatility\nconst calculateSVIVolatility = (params, moneyness, T) => {\n  const k = Math.log(moneyness);\n  const totalVariance = params.a + params.b * (params.rho * (k - params.m) + \n    Math.sqrt((k - params.m) * (k - params.m) + params.sigma * params.sigma));\n  return Math.sqrt(totalVariance / T);\n};\n\n// Calculate Black-Scholes delta\nconst calculateDelta = (iv, moneyness, T) => {\n  const d1 = (Math.log(1/moneyness) + (0.5 * iv * iv) * T) / (iv * Math.sqrt(T));\n  return 0.5 + 0.5 * erf(d1 / Math.sqrt(2));\n};\n\n// Error function approximation\nconst erf = (x) => {\n  const sign = x >= 0 ? 1 : -1;\n  x = Math.abs(x);\n  const a1 = 0.254829592;\n  const a2 = -0.284496736;\n  const a3 = 1.421413741;\n  const a4 = -1.453152027;\n  const a5 = 1.061405429;\n  const p = 0.3275911;\n  const t = 1.0 / (1.0 + p * x);\n  const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);\n  return sign * y;\n};\n\n// Calculate fit quality\nconst calculateFitQuality = (params, data) => {\n  const errors = data.map(option => {\n    const modelIV = calculateSVIVolatility(params, option.moneyness, option.days_to_expiry / 365);\n    return Math.abs(modelIV - option.implied_volatility);\n  });\n  \n  return {\n    mean_absolute_error: errors.reduce((a, b) => a + b, 0) / errors.length,\n    max_error: Math.max(...errors),\n    r_squared: 0.95 // Simplified\n  };\n};\n\nconst optionsData = items.map(item => item.json);\nconst volatilitySurfaces = buildVolatilitySurface(optionsData);\n\nreturn volatilitySurfaces.map(surface => ({ json: surface }));"
      },
      "id": "build-vol-surface",
      "name": "Build Volatility Surface (SVI)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        300
      ]
    },
    {
      "parameters": {
        "operation": "upsert",
        "table": "volatility_surfaces",
        "columns": {
          "surface_id": "={{ $json.symbol + '_' + $json.expiration_date.replace(/[-]/g, '') }}",
          "symbol": "={{ $json.symbol }}",
          "expiration_date": "={{ $json.expiration_date }}",
          "underlying_price": "={{ $json.underlying_price }}",
          "svi_parameters": "={{ $json.svi_parameters }}",
          "volatility_grid": "={{ $json.volatility_grid }}",
          "data_points": "={{ $json.data_points }}",
          "fit_quality": "={{ $json.fit_quality }}",
          "calculation_timestamp": "={{ $json.calculation_timestamp }}",
          "surface_status": "={{ $json.fit_quality.mean_absolute_error < 0.05 ? 'VALID' : 'QUESTIONABLE' }}"
        },
        "additionalFields": {
          "updateKey": "surface_id"
        }
      },
      "id": "store-vol-surface",
      "name": "Store Volatility Surface",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        1120,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-fit-quality",
              "leftValue": "={{ $json.fit_quality.mean_absolute_error }}",
              "rightValue": 0.1,
              "operator": {
                "type": "number",
                "operation": "greaterThan"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-surface-quality",
      "name": "Check Vol Surface Quality",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1340,
        300
      ]
    },
    {
      "parameters": {
        "channel": "={{ $vars.SLACK_DERIVATIVES_CHANNEL }}",
        "text": "⚠️ Volatility Surface Quality Alert\n• Symbol: {{ $json.symbol }}\n• Expiration: {{ $json.expiration_date }}\n• Fit Error: {{ ($json.fit_quality.mean_absolute_error * 100).toFixed(2) }}%\n• Data Points: {{ $json.data_points }}\n• Status: {{ $json.surface_status }}\n• Time: {{ $json.calculation_timestamp }}\n• Action: Review options data quality",
        "additionalFields": {}
      },
      "id": "alert-surface-issues",
      "name": "Alert on Surface Quality Issues",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 1,
      "position": [
        1560,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "// Calculate volatility surface metrics and anomalies\nconst analyzeSurfaceMetrics = (volatilitySurfaces) => {\n  const metrics = [];\n  \n  volatilitySurfaces.forEach(surface => {\n    const grid = surface.volatility_grid;\n    \n    // Calculate term structure\n    const termStructure = calculateTermStructure(grid);\n    \n    // Calculate skew metrics\n    const skewMetrics = calculateSkewMetrics(grid);\n    \n    // Detect volatility arbitrage opportunities\n    const arbitrageChecks = performArbitrageChecks(grid);\n    \n    metrics.push({\n      surface_id: surface.symbol + '_' + surface.expiration_date.replace(/[-]/g, ''),\n      symbol: surface.symbol,\n      expiration_date: surface.expiration_date,\n      term_structure: termStructure,\n      skew_metrics: skewMetrics,\n      arbitrage_checks: arbitrageChecks,\n      analysis_timestamp: new Date().toISOString(),\n      overall_quality: surface.fit_quality.mean_absolute_error < 0.05 ? 'HIGH' : \n                      surface.fit_quality.mean_absolute_error < 0.1 ? 'MEDIUM' : 'LOW'\n    });\n  });\n  \n  return metrics;\n};\n\nconst calculateTermStructure = (grid) => {\n  const tenors = [...new Set(grid.map(p => p.tenor_days))].sort((a, b) => a - b);\n  const atmVols = tenors.map(tenor => {\n    const atmPoint = grid.find(p => p.tenor_days === tenor && Math.abs(p.moneyness - 1) < 0.01);\n    return atmPoint ? atmPoint.implied_volatility : null;\n  }).filter(v => v !== null);\n  \n  return {\n    tenors: tenors,\n    atm_volatilities: atmVols,\n    term_structure_slope: atmVols.length > 1 ? (atmVols[atmVols.length - 1] - atmVols[0]) : 0\n  };\n};\n\nconst calculateSkewMetrics = (grid) => {\n  const tenors = [...new Set(grid.map(p => p.tenor_days))];\n  const skews = tenors.map(tenor => {\n    const points = grid.filter(p => p.tenor_days === tenor);\n    const putSkew = points.find(p => p.moneyness === 0.9)?.implied_volatility;\n    const callSkew = points.find(p => p.moneyness === 1.1)?.implied_volatility;\n    const atmVol = points.find(p => p.moneyness === 1.0)?.implied_volatility;\n    \n    return {\n      tenor_days: tenor,\n      put_skew: putSkew && atmVol ? putSkew - atmVol : null,\n      call_skew: callSkew && atmVol ? callSkew - atmVol : null,\n      total_skew: putSkew && callSkew ? putSkew - callSkew : null\n    };\n  });\n  \n  return {\n    skews_by_tenor: skews,\n    avg_put_skew: skews.reduce((sum, s) => sum + (s.put_skew || 0), 0) / skews.length,\n    avg_call_skew: skews.reduce((sum, s) => sum + (s.call_skew || 0), 0) / skews.length\n  };\n};\n\nconst performArbitrageChecks = (grid) => {\n  // Check for butterfly arbitrage\n  const butterflyViolations = checkButterflyArbitrage(grid);\n  \n  // Check for calendar spread arbitrage\n  const calendarViolations = checkCalendarArbitrage(grid);\n  \n  return {\n    butterfly_arbitrage: butterflyViolations.length === 0 ? 'NO_ARBITRAGE' : 'POSSIBLE_ARBITRAGE',\n    calendar_arbitrage: calendarViolations.length === 0 ? 'NO_ARBITRAGE' : 'POSSIBLE_ARBITRAGE',\n    violation_count: butterflyViolations.length + calendarViolations.length,\n    last_check: new Date().toISOString()\n  };\n};\n\nconst checkButterflyArbitrage = (grid) => []; // Implementation simplified\nconst checkCalendarArbitrage = (grid) => []; // Implementation simplified\n\nconst surfaces = items.map(item => item.json);\nconst surfaceMetrics = analyzeSurfaceMetrics(surfaces);\n\nreturn surfaceMetrics.map(metric => ({ json: metric }));"
      },
      "id": "analyze-surface-metrics",
      "name": "Analyze Surface Metrics & Arbitrage",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        500
      ]
    },
    {
      "parameters": {
        "subject": "Volatility Surface Analysis - {{ $now }}",
        "body": "Volatility Surface Analysis Report:\n\n{{ items.map(item => `Symbol: ${item.json.symbol}\\nExpiration: ${item.json.expiration_date}\\nQuality: ${item.json.overall_quality}\\nTerm Structure Slope: ${(item.json.term_structure.term_structure_slope * 100).toFixed(2)}%\\nAvg Put Skew: ${(item.json.skew_metrics.avg_put_skew * 100).toFixed(2)}%\\nArbitrage Status: ${item.json.arbitrage_checks.butterfly_arbitrage}\\n\\n`).join('') }}\nGenerated: {{ new Date().toISOString() }}",
        "to": "={{ $vars.DERIVATIVES_TEAM_EMAIL }}",
        "additionalFields": {}
      },
      "id": "email-surface-analysis",
      "name": "Email Vol Surface Analysis",
      "type": "n8n-nodes-base.email",
      "typeVersion": 1,
      "position": [
        1340,
        500
      ]
    }
  ],
  "connections": {
    "Volatility Surface Update Trigger": {
      "main": [
        [
          {
            "node": "Fetch Options Chain Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Options Chain Data": {
      "main": [
        [
          {
            "node": "Clean and Validate Options Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clean and Validate Options Data": {
      "main": [
        [
          {
            "node": "Build Volatility Surface (SVI)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Volatility Surface (SVI)": {
      "main": [
        [
          {
            "node": "Store Volatility Surface",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Analyze Surface Metrics & Arbitrage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Volatility Surface": {
      "main": [
        [
          {
            "node": "Check Vol Surface Quality",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Vol Surface Quality": {
      "main": [
        [
          {
            "node": "Alert on Surface Quality Issues",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze Surface Metrics & Arbitrage": {
      "main": [
        [
          {
            "node": "Email Vol Surface Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}